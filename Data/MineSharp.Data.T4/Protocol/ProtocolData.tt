<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="System.Linq" #>
<#@ assembly name="System.Collections" #>
<#@ assembly name="$(SolutionDir)\Data\MineSharp.Data.T4\bin\Debug\net6.0\MineSharp.Data.T4.dll" #>

<#@ import namespace="MineSharp.Data" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="MineSharp.Data.Protocol" #>

<# var msg = "  Generated Protocol Data for Minecraft Version " + MinecraftData.Version + "  "; #>
//<#= new string(Enumerable.Repeat('/', msg.Length).ToArray()) #>//
//<#= msg #>//
//<#= new string(Enumerable.Repeat('/', msg.Length).ToArray()) #>//

using MineSharp.Core.Types;
using MineSharp.Core.Types.Protocol;
using MineSharp.Core.Types.Enums;
using fNbt;

namespace MineSharp.Data.Protocol {
	
	public abstract partial class Packet {
		public static Type GetPacketType(GameState state, PacketFlow direction, int id) {
			return direction switch {
			<# foreach (var direction in new string[] { "clientbound", "serverbound" }) { #>
				PacketFlow.<#= direction.ToUpper() #> => state switch {
			 <# foreach (var ns in ProtocolWriter.GetNamespaces()) { #>
					GameState.<#= ns.ToUpper() #> => id switch {
			  <# foreach (var packet in ProtocolWriter.GetPackets(ns, direction)) { #> 
				<#= packet.Id #> => typeof(<#= MinecraftData.Uppercase(direction) #>.<#= MinecraftData.Uppercase(ns) #>.<#= packet.StructureName #>),<# } #>
			   _ => throw new Exception($"Unknown packet id: {id}, State={state}, Direction={direction}"),
			  },
			 <# } #>
			 _ => throw new Exception($"Unknown packet State={state}, Direction={direction}"),
			 },
            <# } #> 
			_ => throw new Exception($"Unknown packet Direction={direction}"),
			};
		}

	}

	public abstract partial class PacketBuffer {

		public abstract void Write<T>(T value);
		public abstract T Read<T>();
        public abstract T Read<T>(T payload, params object?[]? args) where T : IPacketPayload;
        public abstract object? ReadVoid();
        public abstract void WriteVoid(object? value);
		public abstract T[] ReadArray<T>(int length, params object?[]? args);
		public abstract void WriteArray<T>(T[] value);
		public abstract MinecraftSmeltingFormat ReadMinecraftSmeltingFormat();
		public abstract void WriteMinecraftSmeltingFormat(MinecraftSmeltingFormat value);
		public abstract Tags ReadTags();
		public abstract void WriteTags(Tags value);
		public abstract Ingredient ReadIngredient();
		public abstract void WriteIngredient(Ingredient value);
		

		<# foreach (var type in ProtocolWriter.GetNativeTypes()) { #>
		public abstract <#= type.GetCSharpName() #> Read<#= type.Name #>();
		<# } #>

		<# foreach (var type in ProtocolWriter.GetNativeTypes()) { #>
		public abstract void Write<#= type.Name #>(<#= type.GetCSharpName() #> value);
		<# } #>
	}


}

<# foreach (var direction in new string[] { "clientbound", "serverbound" }) { #>

 <# foreach (var ns in ProtocolWriter.GetNamespaces()) { #>
namespace MineSharp.Data.Protocol.<#= MinecraftData.Uppercase(direction) #>.<#= MinecraftData.Uppercase(ns) #> {

	<# foreach (var packet in ProtocolWriter.GetPackets(ns, direction)) { #> 
	
			public class <#= packet.StructureName #> : Packet {
				public const int ProtocolId = <#= packet.Id #>;

				<# foreach (var field in packet.Fields) { #>
				public <#= field.Type.GetCSharpName() #>? <#= field.Name #> { get; set; }
				<# } #>

				public <#= packet.StructureName #>() : base(ProtocolId) {}

				public override void Read(PacketBuffer buffer) {
					<# foreach (var field in packet.Fields) { #>
					this.<#= field.Name #> = <#= field.Type.Reader #>;
					<# } #>
				}

				public override void Write(PacketBuffer buffer) {
					<# foreach (var field in packet.Fields) { #>
					<#= field.Type.Writer.Replace("%value%", field.Name) #>;
					<# } #>
				}

				<# List<string> writtenStructures = new List<string>();
				    foreach (var field in packet.Fields) { try {
					var type = GetStructureType(field.Type);
					if (type == null) continue;
					while (writtenStructures.Contains(type.StructureName)) {
						var last = type.StructureName.Last();
						var chars = type.StructureName.ToList();
						if (char.IsDigit(last)) {
							last = (char)((int)last + 1);
							chars[type.StructureName.Length - 1] = last;
						} else {
							chars.Add('1');
						}
						type.StructureName = new string(chars.ToArray());
					}
					writtenStructures.Add(type.StructureName);
				#>
				public class <#= type.StructureName #> : IPacketPayload {
					<# WriteStructure(type); #>
				}
					  
				<# } catch (Exception e) { throw new Exception(field.Name, e); } #>
				<# } #>
			}

	<# } #>

}
 <# } #>
<# } #>

<#+
	private ProtocolWriter.ProtoType GetStructureType(ProtocolWriter.ProtoType type) {
		if (type.IsStructure) return type;

		switch (type) {
			case ProtocolWriter.ProtoArray arr: return GetStructureType(arr.Type);
			case ProtocolWriter.ProtoOption opt: return GetStructureType(opt.OptionType);
			case ProtocolWriter.ProtoTopBitSetTerminatedArray tbsta: return GetStructureType(tbsta.Type);
			default: return null;
		}
	}

	void WriteStructure(ProtocolWriter.ProtoType type) {
		switch (type) { 
			case ProtocolWriter.ProtoContainer container:
				WriteContainer(container);
				break;
			case ProtocolWriter.ProtoSwitch @switch:
				WriteSwitch(@switch);
				break;
			case ProtocolWriter.ProtoBitfield bitfield:
				WriteBitfield(bitfield);
				break;
		}
	}

	void WriteBitfield(ProtocolWriter.ProtoBitfield bitfield) { #>

		public <#= ProtocolWriter.GetBitfieldType(bitfield.BitCount, false) #>? Value { get; set; }

		<#+ var bitCount = 0;
		foreach (var field in bitfield.Fields) { #>
			public <#= ProtocolWriter.GetBitfieldType(field.size, field.signed) #> <#= MinecraftData.GetCSharpName(field.name) #> { 
			 get { return (<#= ProtocolWriter.GetBitfieldType(field.size, field.signed) #>)(((<#= ProtocolWriter.GetBitfieldType(bitfield.BitCount, false) #>)Value! >> <#= bitfield.BitCount - (field.size + bitCount) #>) & (<#= (1 << field.size) - 1 #>)); }
			 set { var val = value << <#= bitfield.BitCount - (field.size + bitCount) #>; var inv = ~val; var x = (<#= ProtocolWriter.GetBitfieldType(bitfield.BitCount, false) #>)this.Value! & (<#= ProtocolWriter.GetBitfieldType(bitfield.BitCount, false) #>)inv; this.Value = (<#= ProtocolWriter.GetBitfieldType(bitfield.BitCount, false) #>)(x | (<#= ProtocolWriter.GetBitfieldType(field.size, false) #>)val); }
			} <#+ bitCount += field.size; #>
			<#+
		} #>

		public void Write(PacketBuffer buffer) {
			buffer.Write(this.Value!);
		}

		public void Read(PacketBuffer buffer){
			this.Value = buffer.Read<<#= ProtocolWriter.GetBitfieldType(bitfield.BitCount, false) #>>();
		}

	<#+}

	void WriteContainer(ProtocolWriter.ProtoContainer container) {

	 foreach (var field in container.Fields) { #>
		public <#= field.Type.GetCSharpName() #>? <#= field.Name #> { get; set; }
	<#+} #>

	public <#= container.StructureName #>() { }

	public void Read(PacketBuffer buffer) {
	<#+ foreach (var field in container.Fields) { #>
	this.<#= field.Name #> = <#= field.Type.Reader #>;
	<#+ } #>
	}

	public void Write(PacketBuffer buffer) {
	<#+ foreach (var field in container.Fields) { #>
	<#= field.Type.Writer.Replace("%value%", field.Name) #>;
	<#+ } #>
	}

	<#+ List<string> writtenStructures = new List<string>();
				    foreach (var field in container.Fields) { try {
					var type = GetStructureType(field.Type);
					if (type == null) continue;
					while (writtenStructures.Contains(type.StructureName)) {
						var last = type.StructureName.Last();
						var chars = type.StructureName.ToList();
						if (char.IsDigit(last)) {
							last = (char)((int)last + 1);
							chars[type.StructureName.Length - 1] = last;
						} else {
							chars.Add('1');
						}
						type.StructureName = new string(chars.ToArray());
					}
					writtenStructures.Add(type.StructureName);
				#>
	public class <#= type.StructureName #> : IPacketPayload {
		<#+ WriteStructure(type); #>
	}
					  
	<#+ } catch (Exception e) { throw new Exception(field.Name, e); } #>
	<#+ } #>

	<#+ }


	void WriteSwitch(ProtocolWriter.ProtoSwitch @switch) { #>

	public object? Value { get; set; }
	public <#= @switch.CompareToType.GetCSharpName() #> SwitchState { get; set; }

	public <#= @switch.StructureName #>(object? value, <#= @switch.CompareToType.GetCSharpName() #> switchState) { 
		this.Value = value; 
		this.SwitchState = switchState;
	}

	public <#= @switch.StructureName #>(<#= @switch.CompareToType.GetCSharpName() #> switchState) {
		this.SwitchState = switchState;
	}
	
	public void Read(PacketBuffer buffer) {

		this.Value = SwitchState switch {
			<#+ foreach (var t in @switch.SwitchMap) { #>
			<#+ if (@switch.CompareToType.Name == "String") { Write("\""); } #><#= t.Key #><#+ if (@switch.CompareToType.Name == "String") { Write("\""); } #> => <#= t.Value.Reader #>,
			<#+ } #>
			_ => <#= @switch.DefaultType?.Reader ?? "throw new Exception()" #>
		};

	}

	public void Write(PacketBuffer buffer) {
		switch (SwitchState) {
			<#+ foreach (var t in @switch.SwitchMap) { #>
			case <#+ if (@switch.CompareToType.Name == "String") { Write("\""); } #><#= t.Key #><#+ if (@switch.CompareToType.Name == "String") { Write("\""); } #>: <#= t.Value.Writer.Replace("%value%", "this.Value") #>; break;
			<#+ } #>

		}

	}

	<#+ List<string> writtenStructures = new List<string>();
				    foreach (var field in @switch.SwitchMap) { try {
					var type = GetStructureType(field.Value);
					if (type == null) continue;
					while (writtenStructures.Contains(type.StructureName)) {
						var last = type.StructureName.Last();
						var chars = type.StructureName.ToList();
						if (char.IsDigit(last)) {
							last = (char)((int)last + 1);
							chars[type.StructureName.Length - 1] = last;
						} else {
							chars.Add('1');
						}
						type.StructureName = new string(chars.ToArray());
					}
					writtenStructures.Add(type.StructureName);
				#>
	public class <#= type.StructureName #> : IPacketPayload {
		<#+ WriteStructure(type); #>
	}
					  
	<#+ } catch (Exception e) { throw new Exception(field.Value.Name, e); } #>
	<#+ } #>

	<#+ }

#>