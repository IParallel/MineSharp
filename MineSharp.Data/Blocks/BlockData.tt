<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="System.Linq" #>
<#@ assembly name="$(SolutionDir)\MineSharp.Data\bin\Debug\net6.0\MineSharp.Data.dll" #>

<#@ import namespace="MineSharp.Data" #>
<#@ import namespace="MineSharp.Data.Blocks" #>
<#@ import namespace="System.Linq" #>

<# var msg = "  Generated Block Data for Minecraft Version " + MinecraftData.Version + "  "; #>
//<#= new string(Enumerable.Repeat('/', msg.Length).ToArray()) #>//
//<#= msg #>//
//<#= new string(Enumerable.Repeat('/', msg.Length).ToArray()) #>//

using MineSharp.Core.Types;
using MineSharp.Data.Effects;

namespace MineSharp.Data.Blocks {

	<#
		var blockData = MinecraftData.LoadJson<BlockJsonInfo[]>(MinecraftData.Version, "blocks");
		var blockCollisionData = MinecraftData.LoadJson<BlockCollisionShapeJson>(MinecraftData.Version, "blockCollisionShapes");
	#>

	public static class BlockExtensions {

		public static bool IsSolid(this Block block) {
			var id = block.Id;
			return id == Air.BlockId || id == CaveAir.BlockId || id == VoidAir.BlockId;
		}

		public static int CalculateBreakingTime(this Block block, Item? heldItem, Entity miner) {

			if (block.Hardness == null) throw new InvalidDataException("Hardness is null");

			//TODO: Gamemode creative
			//if (miner.GameMode == Core.Types.Enums.GameMode.Creative) return 0;

			float toolMultiplier = heldItem?.GetToolMultiplier(block) ?? 1;
			float efficiencyLevel = 0; // TODO: Efficiency level
			float hasteLevel = miner.GetEffectLevel(HasteEffect.EffectId) ?? 0;
			float miningFatiqueLevel = miner.GetEffectLevel(MiningfatigueEffect.EffectId) ?? 0;

			toolMultiplier /= MathF.Pow(1.3f, efficiencyLevel);
			toolMultiplier /= MathF.Pow(1.2f, hasteLevel);
			toolMultiplier *= MathF.Pow(0.3f, miningFatiqueLevel);

			float damage = toolMultiplier / (float)block.Hardness;

			bool canHarvest = block.CanBeHarvested(heldItem);
			if (canHarvest) {
				damage /= 30f;
			} else {
				damage /= 100f;
			}

			if (damage > 1) return 0;

			float ticks = MathF.Ceiling(1 / damage);
			return (int)((ticks / 20) * 1000);
		}

		public static bool CanBeHarvested(this Block block, Item? item) {
			if (block.HarvestTools == null) return true;

			if (item == null) return false;

			return block.HarvestTools.Contains(item!.Id);
		}


		public static BlockShape[] GetBlockShape(this Block block) {
			
			var blockType = block.GetType();
			var shapeIndices = (int[])blockType.GetProperty("", System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.NonPublic).GetValue(null);
			float[][] shapeData = AllBlockShapes[shapeIndices[0]];

			return shapeData.Select(x => new BlockShape(x)).ToArray();
		}


		internal static readonly Dictionary<int, float[][]> AllBlockShapes = new Dictionary<int, float[][]>() {
			<# foreach (var shape in blockCollisionData.Shapes) {
			 #> 
			  { <#= shape.Key #>, new float[][] { <#= string.Join(", ", shape.Value.Select(x => $"new float[] {{ { string.Join(", ", x) } }}")) #> } },
			 <#
			 }
			#>
		};
	}

	public static class BlockPalette {

				public static int GetBlockIdByState(int state) => state switch {
			<# 
				foreach (var block in blockData) { #>
					(>= <#= block.MinStateId #>) and (<= <#= block.MaxStateId #>) => <#= block.Id #>,
				<#} #>
				_ => throw new ArgumentException("Block with state " + state + " not found!")
		};

		public static Type GetBlockTypeById(int id) => id switch {
			<#
				foreach (var block in blockData) { #>
					<#= block.Id #> => typeof(<# WriteName(block.Name); #>),
				<#} #>
				_ => throw new ArgumentException("Block with id " + id + " not found!")
		};

		public static Block CreateBlock(Type type, int state, Position pos) {

			if (!type.IsAssignableTo(typeof(Block)))
				throw new ArgumentException();
				
			object[] parameters = new object[] { 
				state, pos
			};

			return (Block)Activator.CreateInstance(type, parameters)!;
		}

		public static Block CreateBlock(int id, int state, Position pos) {
			var type = GetBlockTypeById(id);
			return CreateBlock(type, state, pos);
		}
	}

	<# 
	foreach (var block in blockData) { 
	#>
public class <# WriteName(block.Name); #> : Block {
		public const int BlockId = <#= block.Id #>;
		public const string BlockName = "<#= block.Name #>";
		public const string BlockDisplayName = "<#= block.DisplayName #>";

		public const float BlockHardness = <#= block.Hardness ?? float.MaxValue #>F;
		public const float BlockResistance = <#= block.Resistance #>F;
		public const bool BlockDiggable = <#= block.Diggable.ToString().ToLower() #>;
		public const bool BlockTransparent = <#= block.Transparent.ToString().ToLower() #>;
		public const int BlockFilterLight = <#= block.FilterLight #>;
		public const int BlockEmitLight = <#= block.EmitLight #>;
		public const string BlockBoundingBox = "<#= block.BoundingBox #>";
		public const int BlockStackSize = <#= block.StackSize #>;
		public const string BlockMaterial = "<#= block.Material #>";
		public const int BlockDefaultState = <#= block.DefaultState #>;
		public const int BlockMinStateId = <#= block.MinStateId #>;
		public const int BlockMaxStateId = <#= block.MaxStateId #>;
		<#
			if (block.HarvestTools == null) { #>
		public static readonly int[]? BlockHarvestTools = null;
			<#} else {#>
		public static readonly int[]? BlockHarvestTools = new int[] { <#= string.Join(", ", block.HarvestTools.Keys) #> };
			<#}
		#>

		public static readonly BlockProperties BlockProperties = new BlockProperties(new BlockStateProperty[] { <# foreach (var x in block.States) WritePropertyInfo(x); #> }, <#= block.DefaultState - block.MinStateId #>);	


		internal static readonly int[] BlockShapeIndices = new int[] { <#= string.Join(", ", BlockCollisionShapeJson.GetShapeIndices(blockCollisionData.Blocks[block.Name])) #> };

		public <# WriteName(block.Name); #> () : base(BlockId, BlockName, BlockDisplayName, BlockHardness, BlockResistance, BlockDiggable, BlockTransparent, BlockFilterLight, BlockEmitLight, BlockBoundingBox, BlockStackSize, BlockMaterial, BlockDefaultState, BlockMinStateId, BlockMaxStateId, BlockHarvestTools, BlockProperties) {} 

		public <# WriteName(block.Name); #> (int state, Position pos) : base(state, pos, BlockId, BlockName, BlockDisplayName, BlockHardness, BlockResistance, BlockDiggable, BlockTransparent, BlockFilterLight, BlockEmitLight, BlockBoundingBox, BlockStackSize, BlockMaterial, BlockDefaultState, BlockMinStateId, BlockMaxStateId, BlockHarvestTools, BlockProperties) {}
	}
	<#}#>


	public enum BlockType {
		<#
		foreach (var block in blockData) { #>
			<#= MinecraftData.GetCSharpName(block.Name) #> = <#= block.Id #>,
		<#}	#>
	}
}

<#+ 
	private void WritePropertyInfo(BlockStateJsonInfo info) {
		Write($"new BlockStateProperty(\"{info.Name}\", BlockStateProperty.BlockStatePropertyType.{info.Type[0].ToString().ToUpper() + info.Type.Substring(1)}, { info.NumValues }, ");
			if (info.Values == null) {  
				Write("null");
			 } else {
				Write($"new string[] {{ { string.Join(", ", info.Values.Select(x => '"' + x + '"')) } }}");
			 }
		Write("),");
	}
#>

<#+ 
	void WriteName(string name) {
		name = MinecraftData.GetCSharpName(name);
		Write(name);
	}
#>